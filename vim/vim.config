""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" : plugin
"
    " bootstrap
    let autoload_plug_path = stdpath('data') . '/site/autoload/plug.vim'
    if !filereadable(autoload_plug_path)
      silent execute '!curl -fLo ' . autoload_plug_path . '  --create-dirs
          \ "https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"'
      autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
    endif
    unlet autoload_plug_path

    " Specify a dir for plugins
    call plug#begin('~/.local/share/nvim/plugged')

    " easy motion w/ visual assistents
    Plug 'easymotion/vim-easymotion'

    " search plugin for better search
    Plug 'haya14busa/incsearch.vim'
    Plug 'haya14busa/incsearch-fuzzy.vim'
    Plug 'haya14busa/incsearch-easymotion.vim'

    " colorschemes
    Plug 'morhetz/gruvbox'

    " show indent guide bars to visualize indent levels
    " https://github.com/Yggdroot/indentLine
    Plug 'nathanaelkane/vim-indent-guides'

    " better status line
    " https://github.com/itchyny/lightline.vim
    Plug 'itchyny/lightline.vim'
    Plug 'mengelbrecht/lightline-bufferline'

    " THE git plugin
    " https://github.com/tpope/vim-fugitive
    Plug 'tpope/vim-fugitive'

    " surround everything w/ braces, brackets, ...
    Plug 'tpope/vim-surround'

    " open files at last edit pos
    Plug 'farmergreg/vim-lastplace'

    " split window by visual selection
    Plug 'wellle/visual-split.vim'

    " yank stack
    Plug 'svermeulen/vim-yoink'

    " THE git plugin
    " https://github.com/kien/rainbow_parentheses.vim
    Plug 'kien/rainbow_parentheses.vim'

    " vcs marker
    " https://github.com/mhinz/vim-signify
    Plug 'mhinz/vim-signify'

    " navigating files
    " https://github.com/scrooloose/nerdtree
    Plug 'scrooloose/nerdtree'
    Plug 'Xuyuanp/nerdtree-git-plugin'

    " commenting
    Plug 'scrooloose/nerdcommenter'

    " file finder
    " https://github.com/junegunn/fzf
    Plug 'junegunn/fzf', { 'dir': '~/.local/share/fzf', 'do': './install --all' }
    Plug 'junegunn/fzf.vim'

    " distraction free writing
    " https://github.com/junegunn/goyo.vim
    Plug 'junegunn/goyo.vim'
    Plug 'junegunn/limelight.vim'

    " undotree
    " https://github.com/mbbill/undotree
    Plug 'mbbill/undotree'

    " show filetype icons
    " e.g. in nerdtree, bufferline, ...
    " need a nerd font compatible font installed
    " load after various plugins
    Plug 'ryanoasis/vim-devicons'

    " expand selection
    Plug 'terryma/vim-expand-region'

    " Initialize plugin system
    call plug#end()

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" : general
"
    """"""""""""""""""""""""""""""""""""""""""""""""""""""""
    " :: tabbing
        set expandtab " insert spaces whenever the tab key is pressed
        set tabstop=4
        set shiftwidth=4 " numbers of spaces inserted for indentation
        set list " show all white spaces as char
        " change all tabs in the current line to match tab settings
        map <Leader><A-Space> :.retab<CR>
        " change all tabs match the tab settings
        map <Leader><Leader><A-Space> :retab<CR>

    """"""""""""""""""""""""""""""""""""""""""""""""""""
    " :: undo
        if has('persistent_undo')
            set undolevels=1000
            set undodir='$HOME/.local/nvim/undodir'
            set undofile
        endif

    """"""""""""""""""""""""""""""""""""""""""""""""""""
    " :: other
        set showmatch " show matching bracets when text indicator is over them

        set history=1000 " keep 1000 lines fo command line history

        " sounds
        set noerrorbells
        set novisualbell

        " auto trim tailing whitespaces on save
        augroup onExit
            autocmd!
            autocmd FileType vim,c,cpp,java,php,pl,sh autocmd BufWritePre <buffer> %s/\s\+$//e
        augroup END

        " autoreload vimrc changes and reload
        if has ('autocmd') " Remain compatible with earlier versions
         augroup vimrc     " Source vim configuration upon save
            autocmd! BufWritePost $MYVIMRC source % | echom "Reloaded " . $MYVIMRC | redraw
            autocmd! BufWritePost $MYGVIMRC if has('gui_running') | so % | echom "Reloaded " . $MYGVIMRC | endif | redraw
          augroup END
        endif " has autocmd

        set nocompatible
        set hidden


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" : key mappings
"
    let mapleader = ","

    " yank to the line end (behave like other capital commands)
    nnoremap Y y$

    " create newlines w/o entering insert mode
    nnoremap go o<Esc>k
    nnoremap gO O<Esc>j

    """"""""""""""""""""""""""""""""""""""""""""""""""""
    " :: moving
        " movement by screen line instead of file line (for text wrap)
        nnoremap <silent> j gj
        nnoremap <silent> <down> gj
        nnoremap <silent> <C-j> 20gjzz
        nnoremap <silent> <C-down> 20gjzz
        nnoremap <silent> k gk
        nnoremap <silent> <up> gk
        nnoremap <silent> <C-k> 20gkzz
        nnoremap <silent> <C-up> 20gkzz
        nnoremap <silent> 0 g0
        nnoremap <silent> $ g$

        " move to next empty line
        nnoremap <S-l> }
        " move to prev empty line
        nnoremap <S-h> {

        " navigate split screens easily
        "nmap <silent> <A-k> :wincmd k<CR>
        "nmap <silent> <A-j> :wincmd j<CR>
        nmap <silent> <A-h> :wincmd h<CR>
        nmap <silent> <A-l> :wincmd l<CR>

    """"""""""""""""""""""""""""""""""""""""""""""""""""
    " :: searching
        " highlight search word under cursor w/o jumping to the next AND move
        " to word start, for search-and-replace dingens
        nnoremap <Leader>* *<C-O>heb

        " C-r: Easier search and replace
        xnoremap <C-r> :<C-u>call <SID>get_selection('/')<CR>:%s/\V<C-R>=@/<CR>//gc<Left><Left><Left>
        " Returns visually selected text
        function! s:get_selection(cmdtype) "{{{
            let temp = @s
            normal! gv"sy
            let @/ = substitute(escape(@s, '\'.a:cmdtype), '\n', '\\n', 'g')
            let @s = temp
        endfunction "}}}

    """"""""""""""""""""""""""""""""""""""""""""""""""""
    " :: signify
        nmap <Leader>n <Plug>(signify-next-hunk)
        nmap <Leader><S-n> <Plug>(signify-prev-hunk)

    """"""""""""""""""""""""""""""""""""""""""""""""""""
    " :: fzf
        " This is the default extra key bindings
        let g:fzf_action = {
          \ 'ctrl-t': 'tab split',
          \ 'ctrl-x': 'split',
          \ 'ctrl-v': 'vsplit' }

        " Default fzf layout
        " - down / up / left / right
        let g:fzf_layout = { 'down': '~40%' }

        " In Neovim, you can set up fzf window using a Vim command
        let g:fzf_layout = { 'window': 'enew' }
        let g:fzf_layout = { 'window': '-tabnew' }
        let g:fzf_layout = { 'window': '10new' }

        " Customize fzf colors to match your color scheme
        let g:fzf_colors = {
            \   'fg':      ['fg', 'Normal'],
            \   'bg':      ['bg', 'Normal'],
            \   'hl':      ['fg', 'Comment'],
            \   'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
            \   'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
            \   'hl+':     ['fg', 'Statement'],
            \   'info':    ['fg', 'PreProc'],
            \   'border':  ['fg', 'Ignore'],
            \   'prompt':  ['fg', 'Conditional'],
            \   'pointer': ['fg', 'Exception'],
            \   'marker':  ['fg', 'Keyword'],
            \   'spinner': ['fg', 'Label'],
            \   'header':  ['fg', 'Comment']
            \ }

        " Enable per-command history.
        " CTRL-N and CTRL-P will be automatically bound to next-history and
        " previous-history instead of down and up. If you don't like the change,
        " explicitly bind the keys to down and up in your $FZF_DEFAULT_OPTS.
        let g:fzf_history_dir = '~/.local/share/fzf-history'

        " [Buffers] Jump to the existing window if possible
        let g:fzf_buffers_jump = 1

        " [[B]Commits] Customize the options used by 'git log':
        let g:fzf_commits_log_options = '--graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr"'

        " [Tags] Command to generate tags file
        let g:fzf_tags_command = 'ctags -R'

        " [Commands] --expect expression for directly executing the command
        let g:fzf_commands_expect = 'alt-enter,ctrl-x'

        nmap <Leader><Tab> <Plug>(fzf-maps-n)
        xmap <Leader><Tab> <Plug>(fzf-maps-x)
        omap <Leader><Tab> <Plug>(fzf-maps-o)

        " Insert mode completion
        imap <c-x><c-k> <Plug>(fzf-complete-word)
        imap <c-x><c-f> <Plug>(fzf-complete-path)
        imap <c-x><c-j> <Plug>(fzf-complete-file-ag)
        imap <c-x><c-l> <Plug>(fzf-complete-line)

    """"""""""""""""""""""""""""""""""""""""""""""""""""""""
    " :: goyo
        let g:goyo_width = 120
        nnoremap <Leader><Space> :Goyo<CR>
        function! s:goyo_enter()
          if executable('tmux') && strlen($TMUX)
            silent !tmux set status off
            silent !tmux list-panes -F '\#F' | grep -q Z || tmux resize-pane -Z
          endif
          set noshowmode
          set noshowcmd
          set scrolloff=999
          Limelight
          " ...
        endfunction

        function! s:goyo_leave()
          if executable('tmux') && strlen($TMUX)
            silent !tmux set status on
            silent !tmux list-panes -F '\#F' | grep -q Z && tmux resize-pane -Z
          endif
          set showmode
          set showcmd
          set scrolloff=5
          Limelight!
          " ...
        endfunction

        autocmd! User GoyoEnter nested call <SID>goyo_enter()
        autocmd! User GoyoLeave nested call <SID>goyo_leave()

    """"""""""""""""""""""""""""""""""""""""""""""""""""
    " :: undotree
        nnoremap <Leader>u :UndotreeToggle<CR>
        let g:undotree_WindowLayout = 4

        " Avoid installing twice.
        if exists('g:loaded_undotree')
            finish
        endif
        let g:loaded_undotree = 0
        let g:undotree_SetFocusWhenToggle = 1
        let g:undotree_HighlightChangedText = 1
" Highlight linked syntax type.
" You may chose your favorite through ":hi" command
if !exists('g:undotree_HighlightSyntaxAdd')
    let g:undotree_HighlightSyntaxAdd = "DiffAdd"
endif
if !exists('g:undotree_HighlightSyntaxChange')
    let g:undotree_HighlightSyntaxChange = "DiffChange"
endif
if !exists('g:undotree_HighlightSyntaxDel')
    let g:undotree_HighlightSyntaxDel = "DiffDelete"
endif

    """"""""""""""""""""""""""""""""""""""""""""""""""""
    " :: other
        " toggle background color mode
        map <Leader>bg :let &background=( &background == "dark" ? "light" : "dark" )<CR><CR>

        set wrap
        nnoremap <silent> <Leader>w :set wrap!<CR>

        " underline current line with '-'
        nnoremap <Leader>ul :t.\|s/./-/g\|:nohls<CR>
        " underline current line with '='
        nnoremap <leader>uul :t.\|s/./=/g\|:nohls<CR>

        " duplicate lines - similar to intellij
        function! <SID>duplicateLine_moveLineAndKeepCursorCol()
            let l = line(".")
            let c = col(".")

            normal! Yp

            call cursor(l, c)

            normal! j
        endfun
        nnoremap <C-d> :call <SID>duplicateLine_moveLineAndKeepCursorCol()<CR>

        " Fast saving
        nnoremap <silent><Leader>w :write<CR>
        vnoremap <silent><Leader>w <Esc>:write<CR>
        nnoremap <silent><C-s> :<C-u>write<CR>
        vnoremap <silent><C-s> :<C-u>write<CR>
        cnoremap <silent><C-s> <C-u>write<CR>

        " Save a file with sudo
        " http://forrst.com/posts/Use_w_to_sudo_write_a_file_with_Vim-uAN
        cmap W!! w !sudo tee % >/dev/null

        " Drag current line/s vertically and auto-indent
        vnoremap <S-k> :m-2<CR>gv=gv
        vnoremap <S-up> :m-2<CR>gv=gv
        vnoremap <S-j> :m'>+<CR>gv=gv
        vnoremap <S-down> :m'>+<CR>gv=gv
        noremap  <S-k> :m-2<CR>
        noremap  <S-up> :m-2<CR>
        noremap  <S-j> :m+<CR>
        noremap  <S-down> :m+<CR>


    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" : ui zeuch
    """"""""""""""""""""""""""""""""""""""""""""""""""""""""
    " :: general
    " enable 256 color term
    set t_Co=256
    " enable true color
    if has('termguicolors')
        set termguicolors
    endif

    " oder terminal weit setzen
    set guifont=DroidSansMono\ Nerd\ Font\ 11

    """"""""""""""""""""""""""""""""""""""""""""""""""""""""
    " :: colorscheme-rotz (settings for 'morhetz/gruvbox' scheme)
        set background=dark " start w/ this mode
        "set background=light

        let g:gruvbox_contrast_dark='medium'  " set contrast for dark mode 'hard | ... | soft'
        let g:gruvbox_contrast_light='soft' " set contrast for light mode 'hard | medium | ...'

        let g:gruvbox_italic='1'

        colorscheme gruvbox


    """"""""""""""""""""""""""""""""""""""""""""""""""""""""
    " :: better rainbow parenthesis
        let g:rbpt_colorpairs = [
            \       [ 'brown',      'RoyalBlue3' ],
            \       ['Darkblue',    'SeaGreen3'],
            \       ['darkgray',    'DarkOrchid3'],
            \       ['darkgreen',   'firebrick3'],
            \       ['darkcyan',    'RoyalBlue3'],
            \       ['darkred',     'SeaGreen3'],
            \       ['darkmagenta', 'DarkOrchid3'],
            \       ['brown',       'firebrick3'],
            \       ['gray',        'RoyalBlue3'],
            \       ['black',       'SeaGreen3'],
            \       ['darkmagenta', 'DarkOrchid3'],
            \       ['Darkblue',    'firebrick3'],
            \       ['darkgreen',   'RoyalBlue3'],
            \       ['darkcyan',    'SeaGreen3'],
            \       ['darkred',     'DarkOrchid3'],
            \       ['red',         'firebrick3'],
            \   ]
        let g:rbpt_max = 16
        let g:rbpt_ladcmd_toggle = 0

        au VimEnter * RainbowParenthesesToggle " toggle it on
        au Syntax * RainbowParenthesesLoadRound " ()
        au Syntax * RainbowParenthesesLoadSquare " []
        au Syntax * RainbowParenthesesLoadBraces " {}
        au Syntax * RainbowParenthesesLoadChevrons " <>

    """"""""""""""""""""""""""""""""""""""""""""""""""""""""
    " :: other
        " both absolute and relative line numbers are enabled by default, which produces “hybrid” line numbers.
        " When entering insert mode, relative line numbers are turned off, leaving absolute line numbers turned on.
        " This also happens when the buffer loses focus, so you can glance back at it to see which absolute line
        " you were working on if you need to.
        set number relativenumber " show relative line numbers
        augroup numbertoggle
            autocmd!
            autocmd BufEnter,FocusGained,InsertLeave,WinEnter * if &nu | set rnu   | endif
            autocmd BufLeave,FocusLost,InsertEnter,WinLeave   * if &nu | set nornu | endif
        augroup END

        " Plug: indentLines
        let g:indent_guides_enable_on_vim_startup = 1
        let g:indent_guides_guide_size = 1


""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" :: easymotion: fast motion by typing the activation letter: s
    let g:EasyMotion_do_mapping = 0
    let g:EasyMotion_smartcase = 1
    nmap ss <Plug>(easymotion-s2)
    nmap sd <Plug>(easymotion-s)
    nmap sf <Plug>(easymotion-overwin-f)
    map  sh <Plug>(easymotion-linebackward)
    map  sl <Plug>(easymotion-lineforward)
    map  sj <Plug>(easymotion-j)
    map  sk <Plug>(easymotion-k)
    map  s/ <Plug>(easymotion-sn)
    omap s/ <Plug>(easymotion-tn)
    map  sn <Plug>(easymotion-next)

    map <Leader>l <Plug>(easymotion-lineforward)
    map <Leader>j <Plug>(easymotion-j)
    map <Leader>k <Plug>(easymotion-k)
    map <Leader>h <Plug>(easymotion-linebackward)
    let g:EasyMotion_startofline = 0 " keep cursor column when JK motion   map  sp <Plug>(easymotion-prev)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" :: expand region
    map + <Plug>(expand_region_expand)
    map - <Plug>(expand_region_shrink)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" :: incsearch:
"       -incsearch: highlights all pattern matched (unlike default incsearch)
"       -fuzzy: sucht fehlerhaft
"       -easymotion: jump to result w/ easymotion
    nnoremap <Esc><Esc> :<C-u>nohlsearch<CR>

    map /  <Plug>(incsearch-forward)
    map ?  <Plug>(incsearch-backward)
    map g/ <Plug>(incsearch-stay)

    map <S-z>/ <Plug>(incsearch-fuzzyspell-/)
    map <S-z>? <Plug>(incsearch-fuzzyspell-?)
    map <S-z>g/ <Plug>(incsearch-fuzzyspell-stay)

    map z/ <Plug>(incsearch-easymotion-/)
    map z? <Plug>(incsearch-easymotion-?)
    map zg/ <Plug>(incsearch-easymotion-stay)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" :: lightline+bufferline
    set laststatus=2
    let g:lightline = {
        \       'enable': { "statusline": 1, "tabline": 1 },
        \       'colorscheme': 'wombat',
        \       'mode_map': { 'n': 'N', 'v': 'V', 'i': 'I', 'c': 'C', 'r': 'R', 's': 'S', 't': 'T' },
        \       'active': {
        \           'left': [  [ 'mode', 'paste' ],
        \                      [ 'bufnum', 'gitbranch', 'readonly', 'filename', 'modified' ] ],
        \           'right': [ [ 'lineinfo' ],
        \                      [ 'percent' ],
        \                      [ 'fileformat', 'fileencoding', 'filetype', 'charvaluehex' ] ]
        \       },
        \       'tab': {
        \           'active': [ 'tabnum', 'readonly', 'filename', 'modified' ],
        \           'inactive': [ 'tabnum', 'readonly', 'filename', 'modified' ]
        \       },
        \       'component': {
        \           'charvaluehex': '0x%02B'
        \       },
        \       'component_function': {
        \           'gitbranch': 'fugitive#head'
        \       },
        \   }
    let g:lightline.tabline          = {'left': [['buffers']], 'right': [['close']]}
    let g:lightline.component_expand = {'buffers': 'lightline#bufferline#buffers'}
    let g:lightline.component_type   = {'buffers': 'tabsel'}

    set showtabline=2
    if has('gui_running')
        set guioptions-=e
    endif

    let g:lightline#bufferline#show_number = 2
    let g:lightline#bufferline#number_separator = ': '
    "let g:lightline#bufferline#number_map = {
    "        \ 0: '⁰', 1: '¹', 2: '²', 3: '³', 4: '⁴',
    "        \ 5: '⁵', 6: '⁶', 7: '⁷', 8: '⁸', 9: '⁹'
    "    }

    nmap <Leader>1 <Plug>lightline#bufferline#go(1)
    nmap <Leader>2 <Plug>lightline#bufferline#go(2)
    nmap <Leader>3 <Plug>lightline#bufferline#go(3)
    nmap <Leader>4 <Plug>lightline#bufferline#go(4)
    nmap <Leader>5 <Plug>lightline#bufferline#go(5)
    nmap <Leader>6 <Plug>lightline#bufferline#go(6)
    nmap <Leader>7 <Plug>lightline#bufferline#go(7)
    nmap <Leader>8 <Plug>lightline#bufferline#go(8)
    nmap <Leader>9 <Plug>lightline#bufferline#go(9)
    nmap <Leader>0 <Plug>lightline#bufferline#go(10)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" :: nerdtree
    " auto open nerdtree, when vim is started w/o a file specified
    map <Leader>F :NERDTreeFind<CR>
    map <Leader>f :NERDTreeToggle<CR>
    au StdinReadPre * let s: std_in=1
    au VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

    " automatically close NerdTree when you open a file
    let NERDTreeQuitOnOpen = 1
    " automatically dekete the buffer of the file you just deleted w/ NerdTree
    let NERDTreeAutoDeleteBuffer = 1
    " make NerdTree prettier
    let NERDTreeMinimalUI = 1
    let NERDTreeDirArrows = 1

    " automatically close a tab if the only remaining window is nerdtree
    au bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" :: visual split
    xmap <C-W>gr  <Plug>(Visual-Split-VSResize)
    xmap <C-W>gss <Plug>(Visual-Split-VSSplit)
    xmap <C-W>gsa <Plug>(Visual-Split-VSSplitAbove)
    xmap <C-W>gsb <Plug>(Visual-Split-VSSplitBelow)

    nmap <C-W>gr  <Plug>(Visual-Split-Resize)
    nmap <C-W>gss <Plug>(Visual-Split-Split)
    nmap <C-W>gsa <Plug>(Visual-Split-SplitAbove)
    nmap <C-W>gsb <Plug>(Visual-Split-SplitBelow)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" :: yoink
    nmap <c-n> <plug>(YoinkPostPasteSwapBack)
    nmap <c-p> <plug>(YoinkPostPasteSwapForward)

    nmap p <plug>(YoinkPaste_p)
    nmap P <plug>(YoinkPaste_P)

